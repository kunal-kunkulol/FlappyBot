import pygame
import sys
import random
import bot 
import numpy as np
from pygame.locals import *


cont=1
FPS = 30#fps of the game
SCREENWIDTH  = 288
SCREENHEIGHT = 512
# amount by which base can maximum shift to left
PIPEGAPSIZE  = 100 # gap between upper and lower part of pipe
BASEY        = SCREENHEIGHT * 0.79
# image hitmask  dicts
IMAGES, HITMASKS = {}, {}

# background
background ='assets/sprites/background-day.png'
# pipe 
pipes='assets/sprites/pipe-green.png'

try:
    xrange
except NameError:
    xrange = range


pler2=[]

highscoregen=False
pler=[]

def main():
    global SCREEN, FPSCLOCK
    pygame.init()
    FPSCLOCK = pygame.time.Clock()
    SCREEN = pygame.display.set_mode((SCREENWIDTH, SCREENHEIGHT))
    pygame.display.set_caption('Flappy Bird')

   #load the images 
    IMAGES['base'] = pygame.image.load('assets/sprites/base.png').convert_alpha()
    IMAGES['background'] = pygame.image.load(background).convert()
    IMAGES['player'] = pygame.image.load('assets/sprites/redbird-upflap.png').convert_alpha()
    IMAGES['pipe'] = (
            pygame.transform.rotate(
                pygame.image.load(pipes).convert_alpha(), 180),
            pygame.image.load(pipes).convert_alpha(),
        )
            
    HITMASKS['pipe'] = (
            getHitmask(IMAGES['pipe'][0]),
            getHitmask(IMAGES['pipe'][1]),
        )

        # hitmask for player
    HITMASKS['player'] =getHitmask(IMAGES['player'])
    i=0    
    nexplr=[]
    
    pler.clear()
    #initialize the number of birds at initial level
    for i in range(10*cont):
        #randomly initialise the weights
        w1=np.random.uniform(-0.99,0.99,(6,2))*0.1
        w2=np.random.uniform(-0.99,0.99,(1,6))*0.1
        par={
                'w1':w1,
                'w2':w2,
                'Img':IMAGES['player'],
                'hmk':HITMASKS['player']
                }
        
        w1=np.array(w1)
        w2=np.array(w2)
        #input layer has 2 nodes,hidden layer has 6 nodes and output has 1 node
        w1=w1.reshape((6,2))
        w2=w2.reshape((1,6))
        
        pler.append(bot.bt(par))
        pler2.clear()
    higscore=10
    #start the main game
    maingame(pler,higscore)
    #initiaize the different variables 
    gen=0
    cnt=0
    scrlst=[]
    sumscr=0
    avg=0.0
    scrccnt=0
    #data file for storing generation,their score and their average
    fff=open("data.txt","w+")
    fff.write("den,score,avg\n")
    fff.close()
    gertt=0
    
    #gertt is the number of iterations the loop should run
    while gertt<5000:
        gertt+=1
        
        gen=gen+1
        if(len(pler2)>0):
            if(pler2[len(pler2)-1].score>higscore):
                hh=True
            else:
                hh=False
            npler=selection(pler2,par,hh)
        pler2.clear()
        maingame(npler,higscore)#call for main game with new childs
        
        
        if(pler2[len(pler2)-1].score>2):
            gen=0
        
        cnt=cnt+1
        scrlst.append(pler2[len(pler2)-1].score)
        sumscr=sumscr+pler2[len(pler2)-1].score
        avg=sumscr/cnt
        #print("count of npler::"+str(len(nexplr)))
        #print("count of players dies:"+str(len(pler2)))
        if(pler2[len(pler2)-1].score>higscore):
            #highscoregen=True
            scrccnt=scrccnt+1
            
            np.savetxt("ww1.txt",pler2[len(pler2)-1].w1)
            np.savetxt("ww2.txt",pler2[len(pler2)-1].w2)
            
            print("GENRATION:"+str(cnt)+" Highscore generated::"+str(pler2[len(pler2)-1].score)+" avg"+str(avg))
            higscore=pler2[len(pler2)-1].score
        else:
            print("GENRATION:"+str(cnt)+" score is::"+str(pler2[len(pler2)-1].score)+" avg"+str(avg))
        sss=str(cnt)+","+str(pler2[len(pler2)-1].score)+","+str(avg)+"\n"
        fff=open("data.txt","a+")
        fff.write(sss)
        fff.close()
        #generate new if 15 generations has not scored about certain value
        if(pler2[len(pler2)-1].score<=0 and (gen%15)==0 and avg<=0.5):
            print("GENERATING NEW ")
            avg=0.0
            cnt=0
            sumscr=0
            scrlst.clear()
            for i in range(10*cont):
                w1=np.random.uniform(-0.99,0.99,(6,2))*0.1
                w2=np.random.uniform(-0.99,0.99,(1,6))*0.1
                par={
                'w1':w1,
                'w2':w2,
                'Img':IMAGES['player'],
                'hmk':HITMASKS['player']
                }
        
        
                npler.append(bot.bt(par))
                pler2.clear()
        
    
    #fff.close()    
    return
##################################################################################

#selection between the parents to crossover and mutate
#here hh denotes if the highscore is generated by particular generation
def selection(pler2,par,hh):
    
    #if highscore is generated maximum childs in next generation will be the two top scorer and some will be new breeds
    if hh:
        pear=pler2[len(pler2)-2:len(pler2)]
        le=pear
        pear.extend(le)
        pear.extend(le)
        pear.append(pler2[len(pler2)-1])
        
        baby=crossover(pear[0],pear[1],par)
        for bab in baby:
            pear.append(bab)
        w1=np.random.uniform(-0.99,0.99,(6,2))*0.1
        w2=np.random.uniform(-0.99,0.99,(1,6))*0.1
        par={
                'w1':w1,
                'w2':w2,
                'Img':IMAGES['player'],
                'hmk':HITMASKS['player']
        }
        pear.append(bot.bt(par))
        mutate_chance=80
        for individual in pear:
            if mutate_chance > random.randint(0,100):
                individual = mutate(individual)
        
        return pear
        
        
    
    #if highscore is not generated then top two parents will be next gen and crossover of both these parents will be in next gen and then remaining will be initialized randomly
    top = 2*cont
    parents=pler2[len(pler2)-top:len(pler2)]
    randomsel=1*cont
    lst=random.sample(range(0, len(pler2)-top-1), randomsel)
    baby=crossover(parents[0],parents[1],par)
    #for bab in baby:
    parents.append(baby[random.randint(0,1)])
    
    baby=crossover(parents[random.randint(0, len(parents)-1)],parents[random.randint(0, len(parents)-1)],par)
    #for bab in baby:
    parents.append(baby[random.randint(0,1)])

    
    for indi in lst:
        parents.append(pler2[indi])            
                    
    parlen=len(parents)
    des=len(pler2)-parlen
    
    children=[]
    #for the remaining childs in the next generation
    while len(children)<des-1:
        male = random.randint(0, parlen-1)
        female = random.randint(0, parlen-1)
        
        if male!=female:
            male=parents[male]
            female=parents[female]
            
            baby=crossover(male,female,par)
            
            for bab in baby:
                if len(children)<des:
                    children.append(bab)
    parents.extend(children)
    
    #add some total new creature
    w1=np.random.uniform(-0.99,0.99,(6,2))*0.1
    w2=np.random.uniform(-0.99,0.99,(1,6))*0.1
    par={
                'w1':w1,
                'w2':w2,
                'Img':IMAGES['player'],
                'hmk':HITMASKS['player']
        }
    
    parents.append(bot.bt(par))
    
    #mutate some of the childs in the next layer
    mutate_chance=85
    for individual in parents:
        if mutate_chance > random.randint(0,100):
            individual = mutate(individual)        
    
    return parents

###########################################################################
#crossover between two parents
def crossover(male,female,par):
    
    wm1=male.w1
    wm2=male.w2
    wf1=female.w1
    wf2=female.w2
    #convert to one-d array
    wtm1=wm1.ravel()
    wtm2=wm2.ravel()
    wtf1=wf1.ravel()
    wtf2=wf2.ravel()
        
    
    rrtt=random.randint(0,1)
    child=[]
    child.append(bot.bt(par))
    child.append(bot.bt(par))
    if(rrtt==0):
        rrtt=random.randint(0,11)
        child[0].w2=wf2
        child[1].w2=wm2
        
        
        wg1c1=np.array(np.zeros(12))
        wg1c2=np.array(np.zeros(12))
        
        rte=0
        for rte in range(rrtt):
            wg1c1[rte]=wtm1[rte]
            wg1c2[rte]=wtf1[rte]
        
        rerr=0
        for rerr in range(rrtt,12):
            wg1c1[rerr]=(wtf1[rerr])
            wg1c2[rerr]=(wtm1[rerr])
        
        
        wg1c1=wg1c1.reshape((6,2))
        wg1c2=wg1c2.reshape((6,2))
        
        child[0].w1=wg1c1
        child[1].w1=wg1c2
    else:
        rrtt=random.randint(0,5)
        
        child[0].w1=wm1
        child[1].w1=wf1
        
        wg2c1=np.array(np.zeros(6))
        wg2c2=np.array(np.zeros(6))
        
        rte=0
        for rte in range(rrtt):
            wg2c1[rte]=wtm2[rte]
            wg2c2[rte]=wtf2[rte]
            
        rerr=0
        for rerr in range(rrtt,6):
            wg2c1[rerr]=(wtm1[rerr])
            wg2c2[rerr]=(wtf1[rerr])
        
        
        wg2c1=wg2c1.reshape((1,6))
        wg2c2=wg2c2.reshape((1,6))
        
        child[0].w2=wg2c1
        child[1].w2=wg2c2
        
    #w1 and     
    #child[0].w1=wm1
    #child[0].w2=wf2
    #child[1].w1=wf1
    #child[1].w2=wm2
    return child
    
    #here mutation occurs for w1 or w2 of particular parent
def mutate(indi):
    
    indi.w1=indi.w1.reshape((6,2))
    indi.w2=indi.w2.reshape((1,6))
    
    wt1=indi.w1
    wt2=indi.w2
    rt=random.randint(0,1)
    
    if(rt==1):
        rt1=random.randint(0,5)
        rt2=random.randint(0,1)
        
        wt1[rt1][rt2]=wt1[rt1][rt2]+np.random.uniform(-0.1,0.1)*0.1
        
    else:
        rt2=random.randint(0,5)
        rt1=0
        wt2[rt1][rt2]=wt2[rt1][rt2]+np.random.uniform(-0.1,0.1)*0.1
        
    indi.w1=wt1
    indi.w2=wt2
    return indi


################################################################################
def maingame(pler,highscore):
    
    
    basex = 0
    # amount by which base can maximum shift to left
    baseShift = IMAGES['base'].get_width() - IMAGES['background'].get_width()

    # get 2 new pipes to add to upperPipes lowerPipes list
    newPipe1 = getRandomPipe()
    newPipe2 = getRandomPipe()
    # list of upper pipes
    upperPipes = [
        {'x': SCREENWIDTH + 200, 'y': newPipe1[0]['y']},
        {'x': SCREENWIDTH + 200 + (SCREENWIDTH/2+40), 'y': newPipe2[0]['y']},
    ]

    # list of lowerpipe
    lowerPipes = [
        {'x': SCREENWIDTH + 200, 'y': newPipe1[1]['y']},
        {'x': SCREENWIDTH + 200 + (SCREENWIDTH/2+40), 'y': newPipe2[1]['y']},
    ]
    pipeVelX = -4
    m=0
    #here first initiate the x and y of the players
    for m in range(len(pler)):
        pler[m].initxy()
    
    i1=0
    for i1 in range(len(pler)):
        pler[i1].pixscr=0
        pler[i1].score=0
    gerr=highscore
    while True:
        #for quit
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                pygame.quit()
                sys.exit()
        
        #check for highscore and set next target to +100
        ii=0
        for ii in range(len(pler)):
            if(gerr>0 and pler[ii].score>gerr):
                print("BIRDS ALIVE::"+str(len(pler)))
                print("HIGHSCORE IS::"+str(pler[ii].score))
                gerr+=100
                print("NEXT TARGET IS::"+str(gerr))
        
        #check to whether the bird should flapp or not 
        #here horizontal distance between bird and next pipe and vertical distance between bird and center of the next upper and lower pipe is given        
        i2=0    
        for i2 in range(len(pler)):
            pler[i2].update((upperPipes[0]['x']+IMAGES['pipe'][0].get_width())-pler[i2].xx -15,
                pler[i2].yy  - (upperPipes[0]['y']+IMAGES['pipe'][0].get_height()+50),
                (upperPipes[1]['x']+IMAGES['pipe'][0].get_width())-pler[i2].xx -15,
                pler[i2].yy  - (upperPipes[1]['y']+IMAGES['pipe'][0].get_height()+50)
                )#here parameters are passed to the 
        
        #check for the crash
        i3=0
        for i3 in range(len(pler)):
            #print(i3)
            #print(pler[i3].xx)
            try:
                crashTest = checkCrash({'x': pler[i3].xx, 'y':pler[i3].yy},
                               upperPipes, lowerPipes)
                if crashTest[0]:
                    pler2.append(pler[i3])
                    del pler[i3]
            except:
                crashTest=None
        # check for score
        i4=0
        for i4 in range(len(pler)):
            playerMidPos = pler[i4].xx + IMAGES['player'].get_width() / 2
            for pipe in upperPipes:
                pipeMidPos = pipe['x'] + IMAGES['pipe'][0].get_width() / 2
                if pipeMidPos <= playerMidPos < pipeMidPos + 4:
                    pler[i4].score+= 1
            
        
        
        basex = -((-basex + 100) % baseShift)
        i5=0
         # player's movement
        for i5 in range(len(pler)):
            if pler[i5].playerVelY < pler[i5].playerMaxVelY and not pler[i5].playerFlapped:
                pler[i5].playerVelY += pler[i5].playerAccY
            if pler[i5].playerFlapped:
                pler[i5].playerFlapped = False

        
        
        i7=0
        for i7 in range(len(pler)):
            playerHeight = IMAGES['player'].get_height()
            pler[i7].yy += min(pler[i7].playerVelY, BASEY - pler[i7].yy - playerHeight)
        
        
        
        # move pipes to left
        for uPipe, lPipe in zip(upperPipes, lowerPipes):
            uPipe['x'] += pipeVelX
            lPipe['x'] += pipeVelX

        # add new pipe when first pipe is about to touch left of screen
        if 0 < upperPipes[0]['x'] < 5:
            newPipe = getRandomPipe()
            upperPipes.append(newPipe[0])
            lowerPipes.append(newPipe[1])

        # remove first pipe if its out of the screen
        if upperPipes[0]['x'] < -IMAGES['pipe'][0].get_width():
            upperPipes.pop(0)
            lowerPipes.pop(0)
        
        
        # draw sprites
        SCREEN.blit(IMAGES['background'], (0,0))

        for uPipe, lPipe in zip(upperPipes, lowerPipes):
            SCREEN.blit(IMAGES['pipe'][0], (uPipe['x'], uPipe['y']))
            SCREEN.blit(IMAGES['pipe'][1], (lPipe['x'], lPipe['y']))

        SCREEN.blit(IMAGES['base'], (basex, BASEY))
        
        #playerSurface = pygame.transform.rotate(IMAGES['player'], visibleRot)
        
        i6=0
        for i6 in range(len(pler)):
            SCREEN.blit(pler[i6].img, (pler[i6].xx,pler[i6].yy))
            
        
        
        
        if(len(pler)==0):
            return
        i8=0
        for i8 in range(len(pler)):
            try:
                if((pler[i8].yy+pler[i8].img.get_height())<0):
                    pler2.append(pler[i8])
                    del pler[i8]    
            except:
                asd=False
        
        i9=0
        for i9 in range(len(pler)):
            pler[i9].updscr()
        
        
        
        pygame.display.update()
        FPSCLOCK.tick(FPS)
        pass


##################################################################

def checkCrash(player, upperPipes, lowerPipes):
    """returns True if player collders with base or pipes."""
    #pi = player['index']
    player['w'] = IMAGES['player'].get_width()
    player['h'] = IMAGES['player'].get_height()

    # if player crashes into ground
    if player['y'] + player['h'] >= BASEY - 1:
        return [True, True]
    else:

        playerRect = pygame.Rect(player['x'], player['y'],
                      player['w'], player['h'])
        pipeW = IMAGES['pipe'][0].get_width()
        pipeH = IMAGES['pipe'][0].get_height()

        for uPipe, lPipe in zip(upperPipes, lowerPipes):
            # upper and lower pipe rects
            uPipeRect = pygame.Rect(uPipe['x'], uPipe['y'], pipeW, pipeH)
            lPipeRect = pygame.Rect(lPipe['x'], lPipe['y'], pipeW, pipeH)

            # player and upper/lower pipe hitmasks
            pHitMask = HITMASKS['player']
            uHitmask = HITMASKS['pipe'][0]
            lHitmask = HITMASKS['pipe'][1]

            # if bird collided with upipe or lpipe
            uCollide = pixelCollision(playerRect, uPipeRect, pHitMask, uHitmask)
            lCollide = pixelCollision(playerRect, lPipeRect, pHitMask, lHitmask)

            if uCollide or lCollide:
                return [True, False]

    return [False, False]

def pixelCollision(rect1, rect2, hitmask1, hitmask2):
    """Checks if two objects collide and not just their rects"""
    rect = rect1.clip(rect2)

    if rect.width == 0 or rect.height == 0:
        return False

    x1, y1 = rect.x - rect1.x, rect.y - rect1.y
    x2, y2 = rect.x - rect2.x, rect.y - rect2.y

    for x in xrange(rect.width):
        for y in xrange(rect.height):
            if hitmask1[x1+x][y1+y] and hitmask2[x2+x][y2+y]:
                return True
    return False

def getRandomPipe():
    """returns a randomly generated pipe"""
    # y of gap between upper and lower pipe
    gapY = random.randrange(0, int(BASEY * 0.6 - PIPEGAPSIZE))
    gapY += int(BASEY * 0.2)
    pipeHeight = IMAGES['pipe'][0].get_height()
    pipeX = SCREENWIDTH + 40

    return [
        {'x': pipeX, 'y': gapY - pipeHeight},  # upper pipe
        {'x': pipeX, 'y': gapY + PIPEGAPSIZE}, # lower pipe
    ]

def getHitmask(image):
    """returns a hitmask using an image's alpha."""
    mask = []
    for x in xrange(image.get_width()):
        mask.append([])
        for y in xrange(image.get_height()):
            mask[x].append(bool(image.get_at((x,y))[3]))
    return mask

######################################################################

if __name__ == '__main__':
    main()